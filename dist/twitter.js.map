{"version":3,"file":"twitter.js","sources":["../twitter.js"],"sourcesContent":["const crypto = require(\"crypto\");\r\nconst OAuth = require(\"oauth-1.0a\");\r\nconst Fetch = require(\"cross-fetch\");\r\nconst querystring = require(\"querystring\");\r\nconst Stream = require(\"./stream\");\r\n\r\nconst getUrl = (subdomain, endpoint = \"1.1\") =>\r\n  `https://${subdomain}.twitter.com/${endpoint}`;\r\n\r\nconst createOauthClient = ({ key, secret }) => {\r\n  const client = OAuth({\r\n    consumer: { key, secret },\r\n    signature_method: \"HMAC-SHA1\",\r\n    hash_function(baseString, key) {\r\n      return crypto\r\n        .createHmac(\"sha1\", key)\r\n        .update(baseString)\r\n        .digest(\"base64\");\r\n    }\r\n  });\r\n\r\n  return client;\r\n};\r\n\r\nconst defaults = {\r\n  subdomain: \"api\",\r\n  consumer_key: null,\r\n  consumer_secret: null,\r\n  access_token_key: null,\r\n  access_token_secret: null,\r\n  bearer_token: null\r\n};\r\n\r\n// Twitter expects POST body parameters to be URL-encoded: https://developer.twitter.com/en/docs/basics/authentication/guides/creating-a-signature\r\n// However, some endpoints expect a JSON payload - https://developer.twitter.com/en/docs/direct-messages/sending-and-receiving/api-reference/new-event\r\n// It appears that JSON payloads don't need to be included in the signature,\r\n// because sending DMs works without signing the POST body\r\nconst JSON_ENDPOINTS = [\r\n  \"direct_messages/events/new\",\r\n  \"direct_messages/welcome_messages/new\",\r\n  \"direct_messages/welcome_messages/rules/new\",\r\n  \"collections/entries/curate\"\r\n];\r\n\r\nconst baseHeaders = {\r\n  \"Content-Type\": \"application/json\",\r\n  Accept: \"application/json\"\r\n};\r\n\r\nfunction percentEncode(string) {\r\n  // From OAuth.prototype.percentEncode\r\n  return string\r\n    .replace(/!/g, \"%21\")\r\n    .replace(/\\*/g, \"%2A\")\r\n    .replace(/'/g, \"%27\")\r\n    .replace(/\\(/g, \"%28\")\r\n    .replace(/\\)/g, \"%29\");\r\n}\r\n\r\nclass Twitter {\r\n  constructor(options) {\r\n    const config = Object.assign({}, defaults, options);\r\n    this.authType = config.bearer_token ? \"App\" : \"User\";\r\n    this.client = createOauthClient({\r\n      key: config.consumer_key,\r\n      secret: config.consumer_secret\r\n    });\r\n\r\n    this.token = {\r\n      key: config.access_token_key,\r\n      secret: config.access_token_secret\r\n    };\r\n\r\n    this.url = getUrl(config.subdomain);\r\n    this.oauth = getUrl(config.subdomain, \"oauth\");\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Parse the JSON from a Response object and add the Headers under `_headers`\r\n   * @param {Response} response - the Response object returned by Fetch\r\n   * @return {Promise<object>}\r\n   * @private\r\n   */\r\n  static _handleResponse(response) {\r\n    const headers = response.headers.raw(); // https://github.com/bitinn/node-fetch/issues/495\r\n    // Return empty response on 204 \"No content\"\r\n    if (response.status === 204)\r\n      return {\r\n        _headers: headers\r\n      };\r\n    // Otherwise, parse JSON response\r\n    return response.json().then(res => {\r\n      res._headers = headers; // TODO: this creates an array-like object when it adds _headers to an array response\r\n      return res;\r\n    });\r\n  }\r\n\r\n  async getBearerToken() {\r\n    const headers = {\r\n      Authorization:\r\n        \"Basic \" +\r\n        Buffer.from(\r\n          this.config.consumer_key + \":\" + this.config.consumer_secret\r\n        ).toString(\"base64\"),\r\n      \"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\"\r\n    };\r\n\r\n    const results = await Fetch(\"https://api.twitter.com/oauth2/token\", {\r\n      method: \"POST\",\r\n      body: \"grant_type=client_credentials\",\r\n      headers\r\n    }).then(Twitter._handleResponse);\r\n\r\n    return results;\r\n  }\r\n\r\n  async getRequestToken(twitterCallbackUrl) {\r\n    const requestData = {\r\n      url: `${this.oauth}/request_token`,\r\n      method: \"POST\"\r\n    };\r\n\r\n    let parameters = {};\r\n    if (twitterCallbackUrl) parameters = { oauth_callback: twitterCallbackUrl };\r\n    if (parameters) requestData.url += \"?\" + querystring.stringify(parameters);\r\n\r\n    const headers = this.client.toHeader(\r\n      this.client.authorize(requestData, {})\r\n    );\r\n\r\n    const results = await Fetch(requestData.url, {\r\n      method: \"POST\",\r\n      headers: Object.assign({}, baseHeaders, headers)\r\n    })\r\n      .then(res => res.text())\r\n      .then(txt => querystring.parse(txt));\r\n\r\n    return results;\r\n  }\r\n\r\n  async getAccessToken(options) {\r\n    const requestData = {\r\n      url: `${this.oauth}/access_token`,\r\n      method: \"POST\"\r\n    };\r\n\r\n    let parameters = { oauth_verifier: options.verifier };\r\n    if (parameters) requestData.url += \"?\" + querystring.stringify(parameters);\r\n\r\n    const headers = this.client.toHeader(\r\n      this.client.authorize(requestData, {\r\n        key: options.key,\r\n        secret: options.secret\r\n      })\r\n    );\r\n\r\n    const results = await Fetch(requestData.url, {\r\n      method: \"POST\",\r\n      headers: Object.assign({}, baseHeaders, headers)\r\n    })\r\n      .then(res => res.text())\r\n      .then(txt => querystring.parse(txt));\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Construct the data and headers for an authenticated HTTP request to the Twitter API\r\n   * @param {string} method - \"GET\" or \"POST\"\r\n   * @param {string} resource - the API endpoint\r\n   * @param {object} parameters\r\n   * @return {{requestData: {url: string, method: string}, headers: ({Authorization: string}|OAuth.Header)}}\r\n   * @private\r\n   */\r\n  _makeRequest(method, resource, parameters) {\r\n    const requestData = {\r\n      url: `${this.url}/${resource}.json`,\r\n      method\r\n    };\r\n    if (parameters)\r\n      if (method === \"POST\") requestData.data = parameters;\r\n      else requestData.url += \"?\" + querystring.stringify(parameters);\r\n\r\n    let headers = {};\r\n    if (this.authType === \"User\") {\r\n      headers = this.client.toHeader(\r\n        this.client.authorize(requestData, this.token)\r\n      );\r\n    } else {\r\n      headers = {\r\n        Authorization: `Bearer ${this.config.bearer_token}`\r\n      };\r\n    }\r\n    return {\r\n      requestData,\r\n      headers\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Send a GET request\r\n   * @param {string} resource - endpoint, e.g. `followers/ids`\r\n   * @param {object} parameters\r\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\r\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\r\n   */\r\n  get(resource, parameters) {\r\n    const { requestData, headers } = this._makeRequest(\r\n      \"GET\",\r\n      resource,\r\n      parameters\r\n    );\r\n\r\n    return Fetch(requestData.url, { headers })\r\n      .then(Twitter._handleResponse)\r\n      .then(results =>\r\n        \"errors\" in results ? Promise.reject(results) : results\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Send a POST request\r\n   * @param {string} resource - endpoint, e.g. `users/lookup`\r\n   * @param {object} body - POST parameters object.\r\n   *   Will be encoded appropriately (JSON or urlencoded) based on the resource\r\n   * @returns {Promise<object>} Promise resolving to the response from the Twitter API.\r\n   *   The `_header` property will be set to the Response headers (useful for checking rate limits)\r\n   */\r\n  post(resource, body) {\r\n    const { requestData, headers } = this._makeRequest(\r\n      \"POST\",\r\n      resource,\r\n      JSON_ENDPOINTS.includes(resource) ? null : body // don't sign JSON bodies; only parameters\r\n    );\r\n\r\n    const postHeaders = Object.assign({}, baseHeaders, headers);\r\n    if (JSON_ENDPOINTS.includes(resource)) {\r\n      body = JSON.stringify(body);\r\n    } else {\r\n      body = querystring.stringify(body);\r\n      postHeaders[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\r\n    }\r\n\r\n    return Fetch(requestData.url, {\r\n      method: \"POST\",\r\n      headers: postHeaders,\r\n      body: percentEncode(body)\r\n    })\r\n      .then(Twitter._handleResponse)\r\n      .then(results =>\r\n        \"errors\" in results ? Promise.reject(results) : results\r\n      );\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {string} resource - endpoint, e.g. `statuses/filter`\r\n   * @param {object} parameters\r\n   * @returns {Stream}\r\n   */\r\n  stream(resource, parameters) {\r\n    if (this.authType !== \"User\")\r\n      throw new Error(\"Streams require user context authentication\");\r\n\r\n    const stream = new Stream();\r\n\r\n    // POST the request, in order to accommodate long parameter lists, e.g.\r\n    // up to 5000 ids for statuses/filter - https://developer.twitter.com/en/docs/tweets/filter-realtime/api-reference/post-statuses-filter\r\n    const requestData = {\r\n      url: `${getUrl(\"stream\")}/${resource}.json`,\r\n      method: \"POST\"\r\n    };\r\n    if (parameters) requestData.data = parameters;\r\n\r\n    const headers = this.client.toHeader(\r\n      this.client.authorize(requestData, this.token)\r\n    );\r\n\r\n    const request = Fetch(requestData.url, {\r\n      method: \"POST\",\r\n      headers: {\r\n        ...headers,\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n      },\r\n      body: percentEncode(querystring.stringify(parameters))\r\n    });\r\n\r\n    request\r\n      .then(response => {\r\n        stream.destroy = this.stream.destroy = () => response.body.destroy();\r\n\r\n        response.status === 200\r\n          ? stream.emit(\"start\", response)\r\n          : stream.emit(\"error\", Error(`Status Code: ${response.status}`));\r\n\r\n        response.body\r\n          .on(\"data\", chunk => stream.parse(chunk))\r\n          .on(\"error\", error => stream.emit(\"error\", error))\r\n          .on(\"end\", () => stream.emit(\"end\", response));\r\n      })\r\n      .catch(error => stream.emit(\"error\", error));\r\n\r\n    return stream;\r\n  }\r\n}\r\n\r\nmodule.exports = Twitter;\r\n"],"names":["const","crypto","require","OAuth","Fetch","querystring","Stream","getUrl","subdomain","endpoint","defaults","consumer_key","consumer_secret","access_token_key","access_token_secret","bearer_token","JSON_ENDPOINTS","baseHeaders","Content-Type","Accept","percentEncode","string","replace","Twitter","options","ref","config","Object","assign","authType","client","consumer","signature_method","hash_function","baseString","key","createHmac","update","digest","token","url","oauth","_handleResponse","response","headers","raw","status","json","then","res","_headers","getBearerToken","Buffer","from","this","toString","$await_1","getRequestToken","twitterCallbackUrl","parameters","requestData","stringify","toHeader","authorize","text","txt","parse","$await_2","getAccessToken","verifier","secret","$await_3","_makeRequest","method","resource","data","get","results","Promise","reject","post","body","includes","postHeaders","JSON","stream","Error","destroy","emit","on","chunk","error","catch","module","exports"],"mappings":"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"}